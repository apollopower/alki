"""
Image Builder for Alki

Handles creation of container images from deployment bundles for edge deployment.
Supports multiple base images and runtimes with optimized configurations.
"""

import json
import logging
import subprocess
import tempfile
import requests
import time
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, Any, List, Optional


logger = logging.getLogger(__name__)


@dataclass
class ImageBuildResult:
    """Result of a container image build operation"""

    success: bool
    image_tag: str
    size_mb: Optional[float] = None
    build_time_seconds: Optional[float] = None
    error: Optional[str] = None
    build_log: Optional[str] = None


class ImageBuilder:
    """
    Container image builder for Alki bundles.

    Creates optimized container images with llama-server runtime
    for deploying GGUF models at the edge.
    """

    # Base image options
    BASE_IMAGES = {
        "alpine": "ghcr.io/ggml-org/llama.cpp:server-alpine",
        "ubuntu": "ghcr.io/ggml-org/llama.cpp:server-ubuntu",
        "debian": "ghcr.io/ggml-org/llama.cpp:server",  # default
        "cuda": "ghcr.io/ggml-org/llama.cpp:server-cuda",  # GPU support
    }

    def __init__(self, docker_client: Optional[str] = "docker"):
        """
        Initialize ImageBuilder.

        Args:
            docker_client: Docker client command (default: "docker")
        """
        self.docker_client = docker_client
        self._check_docker_available()

    def _check_docker_available(self) -> bool:
        """Check if Docker is available and running"""
        try:
            result = subprocess.run(
                [self.docker_client, "version"],
                capture_output=True,
                text=True,
                timeout=10,
            )
            if result.returncode != 0:
                raise RuntimeError(f"Docker not available: {result.stderr}")
            return True
        except (subprocess.TimeoutExpired, FileNotFoundError) as e:
            raise RuntimeError(f"Docker not available: {e}")

    def generate_dockerfile(
        self,
        bundle_path: Path,
        base_image: str = "debian",
        runtime_config: Optional[Dict[str, Any]] = None,
    ) -> str:
        """
        Generate Dockerfile content for a bundle.

        Args:
            bundle_path: Path to bundle directory
            base_image: Base image type (alpine, ubuntu, debian)
            runtime_config: Runtime configuration overrides

        Returns:
            Dockerfile content as string
        """
        if base_image not in self.BASE_IMAGES:
            raise ValueError(
                f"Unsupported base image: {base_image}. Choose from: {list(self.BASE_IMAGES.keys())}"
            )

        # Load bundle manifest
        manifest_path = bundle_path / "metadata" / "manifest.json"
        if not manifest_path.exists():
            raise ValueError(f"Bundle manifest not found: {manifest_path}")

        with open(manifest_path) as f:
            manifest_data = json.load(f)

        # Get primary model (first artifact)
        if not manifest_data.get("artifacts"):
            raise ValueError("Bundle has no model artifacts")

        primary_artifact = manifest_data["artifacts"][0]
        # Use the actual filename from the bundle URI, not the original filename
        model_uri = primary_artifact["uri"]
        model_filename = Path(model_uri).name

        # Get runtime defaults
        defaults = manifest_data.get("defaults", {})
        ctx_size = (
            runtime_config.get("ctx", defaults.get("ctx", 2048))
            if runtime_config
            else defaults.get("ctx", 2048)
        )
        ngl = (
            runtime_config.get("ngl", defaults.get("ngl", 0))
            if runtime_config
            else defaults.get("ngl", 0)
        )
        host = runtime_config.get("host", "0.0.0.0") if runtime_config else "0.0.0.0"
        port = runtime_config.get("port", 8080) if runtime_config else 8080

        # Build CMD arguments
        cmd_args = [
            "-m",
            f"/app/models/{model_filename}",
            "--host",
            host,
            "--port",
            str(port),
            "--ctx-size",
            str(ctx_size),
            "--jinja",
        ]
        if ngl > 0:
            cmd_args.extend(["--n-gpu-layers", str(ngl)])

        cmd_str = ", ".join(f'"{arg}"' for arg in cmd_args)

        # Generate Dockerfile
        dockerfile_content = f"""# Generated by Alki Image Builder
FROM {self.BASE_IMAGES[base_image]}

# Set working directory
WORKDIR /app

# Copy bundle contents
COPY models/ /app/models/
COPY metadata/ /app/metadata/

# Expose port
EXPOSE {port}

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \\
    CMD curl -f http://localhost:{port}/health || exit 1

# Run llama-server (base image has llama-server as ENTRYPOINT, so we just pass arguments)
CMD [{cmd_str}]
"""

        return dockerfile_content

    def build_image(
        self,
        bundle_path: Path,
        tag: str,
        base_image: str = "debian",
        runtime_config: Optional[Dict[str, Any]] = None,
        push: bool = False,
        build_args: Optional[Dict[str, str]] = None,
    ) -> ImageBuildResult:
        """
        Build container image from bundle.

        Args:
            bundle_path: Path to bundle directory
            tag: Docker image tag
            base_image: Base image type
            runtime_config: Runtime configuration overrides
            push: Whether to push image to registry
            build_args: Additional build arguments

        Returns:
            ImageBuildResult with build status and metadata
        """
        start_time = time.time()

        try:
            # Validate bundle
            if not bundle_path.exists():
                raise ValueError(f"Bundle path does not exist: {bundle_path}")

            # Generate Dockerfile
            dockerfile_content = self.generate_dockerfile(
                bundle_path, base_image, runtime_config
            )

            # Create temporary build context
            with tempfile.TemporaryDirectory() as temp_dir:
                temp_path = Path(temp_dir)

                # Copy bundle contents to build context
                models_dir = temp_path / "models"
                metadata_dir = temp_path / "metadata"
                models_dir.mkdir()
                metadata_dir.mkdir()

                # Copy models
                bundle_models = bundle_path / "models"
                if bundle_models.exists():
                    for model_file in bundle_models.glob("*.gguf"):
                        dest_file = models_dir / model_file.name
                        dest_file.write_bytes(model_file.read_bytes())

                # Copy metadata
                bundle_metadata = bundle_path / "metadata"
                if bundle_metadata.exists():
                    for meta_file in bundle_metadata.glob("*"):
                        if meta_file.is_file():
                            dest_file = metadata_dir / meta_file.name
                            dest_file.write_text(meta_file.read_text())

                # Write Dockerfile
                dockerfile_path = temp_path / "Dockerfile"
                dockerfile_path.write_text(dockerfile_content)

                # Build image
                build_cmd = [self.docker_client, "build", "-t", tag, "."]

                if build_args:
                    for key, value in build_args.items():
                        build_cmd.extend(["--build-arg", f"{key}={value}"])

                logger.info(f"Building image {tag} from {bundle_path}")
                result = subprocess.run(
                    build_cmd,
                    cwd=temp_path,
                    capture_output=True,
                    text=True,
                    timeout=600,  # 10 minute timeout
                )

                if result.returncode != 0:
                    return ImageBuildResult(
                        success=False,
                        image_tag=tag,
                        error=f"Docker build failed: {result.stderr}",
                        build_log=result.stdout,
                    )

                # Get image size
                size_mb = self._get_image_size(tag)

                # Push if requested
                if push:
                    push_result = subprocess.run(
                        [self.docker_client, "push", tag],
                        capture_output=True,
                        text=True,
                        timeout=300,
                    )
                    if push_result.returncode != 0:
                        logger.warning(f"Failed to push image: {push_result.stderr}")

                build_time = time.time() - start_time

                return ImageBuildResult(
                    success=True,
                    image_tag=tag,
                    size_mb=size_mb,
                    build_time_seconds=build_time,
                    build_log=result.stdout,
                )

        except Exception as e:
            build_time = time.time() - start_time
            return ImageBuildResult(
                success=False,
                image_tag=tag,
                build_time_seconds=build_time,
                error=str(e),
            )

    def _get_image_size(self, tag: str) -> Optional[float]:
        """Get image size in MB"""
        try:
            result = subprocess.run(
                [self.docker_client, "images", tag, "--format", "{{.Size}}"],
                capture_output=True,
                text=True,
                timeout=10,
            )
            if result.returncode == 0:
                size_str = result.stdout.strip()
                # Parse size (e.g., "1.2GB", "500MB")
                if size_str.endswith("GB"):
                    return float(size_str[:-2]) * 1024
                elif size_str.endswith("MB"):
                    return float(size_str[:-2])
                elif size_str.endswith("KB"):
                    return float(size_str[:-2]) / 1024
        except Exception as e:
            logger.warning(f"Could not get image size: {e}")
        return None

    def list_images(self, filter_tag: Optional[str] = None) -> List[Dict[str, Any]]:
        """
        List available images.

        Args:
            filter_tag: Optional tag filter

        Returns:
            List of image metadata
        """
        try:
            cmd = [self.docker_client, "images", "--format", "json"]
            if filter_tag:
                cmd.extend(["--filter", f"reference={filter_tag}"])

            result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)

            if result.returncode != 0:
                logger.error(f"Failed to list images: {result.stderr}")
                return []

            images = []
            for line in result.stdout.strip().split("\n"):
                if line:
                    try:
                        image_data = json.loads(line)
                        images.append(image_data)
                    except json.JSONDecodeError:
                        continue

            return images
        except Exception as e:
            logger.error(f"Error listing images: {e}")
            return []

    def _wait_for_container_healthy(
        self, container_name: str, timeout: int = 60
    ) -> bool:
        """
        Wait for container to be healthy according to its health check.

        Args:
            container_name: Name of the container to check
            timeout: Timeout in seconds

        Returns:
            True if container becomes healthy, False if timeout
        """
        start_time = time.time()
        while time.time() - start_time < timeout:
            status_cmd = [
                self.docker_client,
                "inspect",
                "--format",
                "{{.State.Health.Status}}",
                container_name,
            ]
            result = subprocess.run(status_cmd, capture_output=True, text=True)

            if result.returncode == 0:
                health_status = result.stdout.strip()
                logger.debug(
                    f"Container {container_name} health status: {health_status}"
                )

                if health_status == "healthy":
                    return True
                elif health_status == "unhealthy":
                    logger.warning(f"Container {container_name} became unhealthy")
                    return False

            time.sleep(1)  # Poll every second

        logger.warning(
            f"Timeout waiting for container {container_name} to become healthy"
        )
        return False

    def test_image(self, tag: str, timeout: int = 60) -> Dict[str, Any]:
        """
        Test image by running it and checking health.

        Args:
            tag: Docker image tag to test
            timeout: Timeout in seconds

        Returns:
            Test result dictionary
        """
        container_name = f"alki-test-{tag.replace(':', '-').replace('/', '-')}"

        try:
            # Run container in background
            run_cmd = [
                self.docker_client,
                "run",
                "-d",
                "--name",
                container_name,
                "-p",
                "0:8080",  # Use random port
                tag,
            ]

            result = subprocess.run(run_cmd, capture_output=True, text=True, timeout=30)

            if result.returncode != 0:
                return {
                    "success": False,
                    "error": f"Failed to start container: {result.stderr}",
                }

            container_id = result.stdout.strip()

            # Wait for container to be healthy
            if not self._wait_for_container_healthy(container_name, timeout=30):
                return {
                    "success": False,
                    "error": "Container failed to become healthy within timeout",
                }

            # Get container port
            port_cmd = [self.docker_client, "port", container_name, "8080"]
            port_result = subprocess.run(port_cmd, capture_output=True, text=True)

            if port_result.returncode != 0:
                return {"success": False, "error": "Could not determine container port"}

            # Extract port number
            port_info = port_result.stdout.strip()
            if ":" in port_info:
                host_port = port_info.split(":")[-1]
            else:
                host_port = "8080"

            # Test health endpoint
            try:
                health_url = f"http://localhost:{host_port}/health"
                response = requests.get(health_url, timeout=10)
                health_ok = response.status_code == 200
            except Exception:
                health_ok = False

            # Test models endpoint
            try:
                models_url = f"http://localhost:{host_port}/v1/models"
                response = requests.get(models_url, timeout=10)
                models_ok = response.status_code == 200
                models_data = response.json() if models_ok else None
            except Exception:
                models_ok = False
                models_data = None

            return {
                "success": health_ok and models_ok,
                "container_id": container_id,
                "port": host_port,
                "health_check": health_ok,
                "models_endpoint": models_ok,
                "models_data": models_data,
            }

        except Exception as e:
            return {"success": False, "error": str(e)}
        finally:
            # Clean up container
            try:
                subprocess.run(
                    [self.docker_client, "stop", container_name],
                    capture_output=True,
                    timeout=10,
                )
                subprocess.run(
                    [self.docker_client, "rm", container_name],
                    capture_output=True,
                    timeout=10,
                )
            except Exception:
                pass
